# Systèmes d'Information Géographique & Cartographie {#SIG}

::: {.infobox .caution data-latex="{caution}"}
**Work In Progress**
:::

## Qu'est-ce qu'un SIG ? {#whatis-sig}

<!-- TODO : Développer l'utilité des SIG dans les prises de décision --> 
<!-- 
    TODO : Ajouter des infos provenant de
    https://www.notre-planete.info/terre/outils/sig.php
-->

Un Système d'Information Géographique est, comme tout Système d'Information
[^SI], un ensemble organisé de ressources ayant pour fonction de collecter,
stocker, traiter et diffuser des informations [^SIG]. Ici, ces informations
(généralement informatisées) sont des données géospatiales stockées sous forme
de couches d'informations superposées et reliées les unes aux autres par un
référentiel cartographique [^Référentiel]. Les SIG sont devenus des outils
essentiels dans de nombreux domaines tels que l'écologie, la médecine ou la
sociologie.

Pour aider les utilisateurs au traitement des données géospatiales, il existe de
performants et très utilisés logiciels gratuits ou payants tels que
[QGis](https://www.qgis.org/fr/site/) ou
[ArcGIS](https://www.arcgis.com/index.html). Ces logiciels offrent une approche
graphique à la lecture, l'écriture, la manipulation et la visualisation des
données. Ceci peut néanmoins limiter la reproductibilité et l'automatisation des
projets. Pour remédier à cela, de nombreux langages de programmation peuvent
être utilisés pour écrire et partager des scripts. Parmi les plus utilisés, il y
a [Python](https://www.python.org/) (qui est notamment utilisé pour la
conception de plugins dans les logiciels de SIG) et
[R](https://www.r-project.org/about.html) (dont les scripts sont maintenant
exécutables dans QGis). En plus de cela, l'approche en lignes de commande permet
de se libérer de certaines contraintes imposées par ces logiciels ainsi que
d'avoir plus de contrôle sur ce que l'ont fait (même si ces logiciels sont de
plus en plus performants).

[^SI]: Cf. le cours sur
[Openclassroom](https://openclassrooms.com/fr/courses/2100086-decouvrez-le-monde-des-systemes-dinformation).
[^SIG]: Cf. la page Wikipédia sur le
[Système d'Information Géographique](https://fr.wikipedia.org/wiki/Syst%C3%A8me_d%27information_g%C3%A9ographique).
[^Référentiel]: Fond de carte représentant un territoire géographique sur lequel
peuvent venir s'insérer de nouvelles données cartographiques.

## R en tant que SIG {#R-sig}

Afin d'avoir un bon aperçu et une bonne base sur l'utilisation de R en tant que
SIG, je vous invite à lire le livre *Geocomputation with R* de @geocomputation.
Ce livre est mis à jour régulièrement et consultable gratuitement à cette
adresse : <https://geocompr.robinlovelace.net/>. Si vous préférez le format
papier et/ou voulez soutenir les auteurs, il est bien sûr disponible à l'achat.

Ayant commencé à apprendre les analyses statistiques avec R, c'est naturellement
que je me suis tourné vers ce langage pour la cartographie et l'analyse des
données géospatiales. En effet, la communauté de R a créé de performants et
magnifiques packages de cartographie et de géocalcul libres, gratuits et bien
documentés. Je m'intéresserai donc de plus près à ce qu'offre par exemple Python
lorsque j'aurai maîtrisé suffisamment R. Un autre langage élégant et très récent
qui est à regarder de très près est [Julia](https://julialang.org/), qui offrira
certainement des packages rapides et performants au fur et à mesure de sa
maturité. Par ailleurs, même si des programmes manqueraient à R ou si d'autres
langages possèdent des programmes plus adaptés pour certaines tâches, des
packages R offrent la possibilité d'en faciliter l'accès. Par exemple, les
packages tels que [`Rcpp`](https://github.com/RcppCore/Rcpp) et
[`Reticulate`](https://rstudio.github.io/reticulate/) permettent l'utilisation
de programmes écrits respectivement en C++ et Python.

D'autres caractéristiques intéressantes de R sont sa flexibilité et sa constante
évolution. Par exemple, il offre maintenant la possibilité de faire facilement
des applications web et des cartes interactives notamment via les packages
[`Shiny`](https://shiny.rstudio.com/) et
[`Leaflet`](https://rstudio.github.io/leaflet/). Il offre par la même occasion
divers outils d'analyses avancées, de modélisation et de visualisation qui sont
mis à jour et améliorés régulièrement.

Pour plus d'informations concernant les atouts de R en tant que SIG ainsi qu'un
bref aperçu de l'utilité des autres langages tels que Python, Java et C++, je
vous invite à lire le chapitre [Why use R for
geocomputation](https://geocompr.robinlovelace.net/intro.html#why-use-r-for-geocomputation)
du livre de @geocomputation.

## La représentation des données : les *vecteurs* et les *rasters* {#data-sig}

Pour représenter numériquement les données spatiales, deux modèles de base sont
utilisés : les *vecteurs* (mode vectoriel) et les *rasters* (mode matriciel).
L'une des principales différences entre ces deux modèles est qu'un vecteur est
un *objet* (ou entité) tandis que le raster est une *image*. Ainsi, les vecteurs
sont constitués de points, de lignes et de polygones créés à partir d'équations
mathématiques, tandis que les rasters sont des grilles constituées de cellules
de même taille (les pixels). C'est cette différence qui fait que les vecteurs ne
perdent pas en netteté lorsque l'on zoome dessus, tandis que les images
(rasters) deviennent floues (elles « pixelisent »). Par ailleurs, la différence
dans la manière de stocker ces deux modèles fait que les fichiers liés aux
vecteurs ont une taille bien inférieure que ceux liés aux raster.  
Sous R, les vecteurs et les rasters sont travaillés respectivement avec les
packages `sf` et `raster`.

### Les vecteurs {#vectors}

Un vecteur est une image vectorielle ou dessin mathématique constitué de deux
composantes : une **composante attributaire** permettant de l'identifier, et une
**composante graphique** décrivant sa géométrie. Il est localisé grâce à un
Système de Coordonnées de Référence (ou CRS pour *Coordinate Reference System*
en anglais). Les vecteurs sont basiquement composés de nœuds ou sommets qui sont
des **points dans l'espace**. À partir de ces sommets, des **formules
mathématiques** sont appliquées pour créer des **formes géométriques**. S'il n'y
a qu'un sommet, le vecteur est simplement un point. S'il y a plusieurs sommets
et que les liaisons ne forment pas une forme géométrique fermée, alors cela
forme une ligne. Si la forme est fermée, le vecteur est un polygone. La
géométrie des points est généralement en deux dimensions ($x =$ longitude, $y =$
latitude), mais peut être parfois en trois dimensions si une valeur $z$
additionnelle est ajoutée (notamment pour représenter la hauteur au-dessus du
niveau de la mer).  
Les vecteurs permettent donc de représenter des **données discrètes** avec des
**formes bien définies dans l'espace**.

Pour stocker la géométrie de ces **entités géographiques**,
l'OGC [^OGC] ([*Open Geospatial Consortium*](https://www.ogc.org/)) a développé
un modèle standardisé pour les Bases de Données Spatiales (BDS). Ce modèle
s'appelle **Modèle d'Entité Simple** (SFA pour [*Simple Feature
Access*](https://www.ogc.org/standards/sfa) en anglais) et permet de définir des
fonctions pour accéder, faire des calculs et construire les données, dans le but
de représenter les objets dans la réalité. C'est un modèle de données très
largement supporté dans la plupart des logiciels SIG (dont QGIS) et a
l'avantage de rendre le travail totalement transférable d'un projet à un autre
grâce à une architecture commune.

Pour amener ce modèle dans R, le package `sf` a ainsi été créé pour succéder au
package `sp` sur le long terme [^sf-vignette]. Les différents **types de
géométrie** définis par la norme standardisée de l'OGC sont donc inclus dans ce
package (fig. \@ref(fig:sfclasses)). Ces types de géométrie permettent de créer
les entités, qui sont la **représentation d'un objet dans le monde réel** (comme
un bâtiment, un champ ou un arbre). Chaque entité peut alors faire partie par
exemple du type `POINT`, `POLYLIGNE` (`LINESTRING`) ou `POLYGONE`. En plus de
cela, il est possible de créer d'autres entités à partir de l'agrégation de ces
entités basiques (formant des `MULITPOINTS`, des `MULTIPOLYLIGNES` et des
`MULTIPOLYGONES`). Une seule entité contenant plusieurs types de géométrie
différents est alors de type « collection de géométrie » (`GEOMETRYCOLLECTION`).  
Ces 7 types de géométrie précédemment cités font partis des types les plus
utilisés.

(ref:sfclasses) Exemple des différents types de géométrie supportés par le package `sf` (source : <https://geocompr.robinlovelace.net/spatial-class.html#intro-sf>)

```{r sfclasses, echo=FALSE, fig.cap='(ref:sfclasses)'}
knitr::include_graphics("images/sf-classes.png")
```

Le package `sf` est multitâche, il permet de : lire et écrire des fichiers de
données spatiales via la bibliothèque
[GEOS](https://www.osgeo.org/projects/geos/) ; faire des opérations géométriques
via la bibliothèque [GDAL](https://gdal.org/) ; mais aussi représenter et
transformer des systèmes de coordonnées projetées, à partir de la
bibliothèque [PROJ](https://proj.org/).

#### Lecture des fichiers de données spatiales pour les vecteurs

Pour avoir un aperçu des objets `sf` sous R, nous allons prendre pour exemple
les données de localisation des Réserves Naturelles Nationales (RNN) de la
France métropolitaine (Tableau \@ref(tab:data-rnn)). Ces données proviennent de
l'Inventaire National du Patrimoine Naturel
([INPN](https://inpn.mnhn.fr/accueil/index)) et elles sont trouvables sur le
[site du gouvernement](https://www.data.gouv.fr/fr/datasets/inpn-donnees-du-programme-espaces-proteges/).

Plusieurs formats de fichier peuvent être utilisés pour stocker les données des
vecteurs. Les plus utilisés sont le format *Shapefile* (**.shp**) de la société
ESRI, les formats *Keyhole Markup Language* (**.kml**) de Google (et qui peut
être compressé sous le format **.kmz**), ou aussi le format *Geographic Markup
Language* (**.gml**) développé par l'OGC.

Concernant les données spatiales des RNN, elles sont téléchargeables au format
*Shapefile*. Il faut alors savoir que le format *Shapefile* est toujours
accompagné d'autres fichiers, dont les plus importants sont le fichier **.dbf**
contenant les données attributaires, ainsi que le fichier **.shx** contenant
l'index de la géométrie. Le fichier **.shp** contient, lui, les caractéristiques
géométriques des différentes entités. C'est pour cela que lorsqu'on télécharge
des données au format *Shapefile*, on télécharge en réalité tout un dossier
contenant plusieurs fichiers.

(ref:data-rnn) Jeu de données spatiales montrant les Réserves Naturelles Nationales de la France métropolitaine. 

Une fois le package `sf` chargé, pour lire les données spatiales il faut
utiliser la fonction `st_read()`. Pour cet exemple, il suffit alors de lui
donner le chemin d'accès au fichier **.shp**. Les autres fichiers qui lui sont
liés doivent être stockés au même endroit. Pour plus d'informations sur les
différents paramètres et les différentes possibilités de cette fonction, il ne
faut pas hésiter à aller lire sa documentation.

```{r load-rnn, warning=FALSE, message=FALSE}
library("sf") # Chargement du package sf

# Lecture de la base de données
data_rnn <- st_read("examples/rnn2019_12/N_ENP_RNN_S_000.shp")
```

Des informations intéressantes sont alors affichées après lecture du fichier. On peut y lire dans l'ordre : le chemin d'accès du fichier source ; le type de l'objet ainsi créé avec quelques informations sur ses éléments, 

En regardant l'objet `sf` alors créé, on peut s'apercevoir qu'il a la forme d'un
tableau de données comme on a l'habitude de voir. Cette caractéristique permet
de le manipuler facilement, notamment via le package
[`dplyr`](http://larmarange.github.io/analyse-R/manipuler-les-donnees-avec-dplyr.html).

```{r data-rnn}
# Visualisation du tableau de données
knitr::kable(data_rnn, caption = "(ref:data-rnn)") %>%
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hovered", "condensed", "responsive"),
    font_size = 12,
    fixed_thead = TRUE
  ) %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

```{r str-data-rnn}
# Visualisation de la structure du tableau de données
str(data_rnn)
class(data_rnn$geometry)
attributes(data_rnn$geometry)
st_crs(data_rnn)$proj4string
```


#### Création de cartes à partir de vecteurs

(ref:plot-rnn) Carte montrant la localisation géographique (point rouge) des Réserves Naturelles Nationales de la France métropolitaine. Un zoom a été fait pour apercevoir la délimitation de la Réserve Nationale de la Haute Chaîne du Jura.

```{r plot-rnn, fig.cap='(ref:plot-rnn)', message=FALSE, warning=FALSE, out.width="100%"}
library("ggplot2")
library("ggspatial") # Extension de ggplot2 pour la cartographie
library("ggthemes") # Ajoute d'autres thèmes à ggplot2
library("ggrepel") # Permet un meilleur affichage des étiquettes
library("patchwork") # Permet de combiner les graphiques
library("dplyr") # Permet la manipulation des données
library("ggforce") # Extension de ggplot2 pour de nouveaux geom_*

# Ajout des départements français.
regions <- st_read("examples/regions-20180101-shp/regions-20180101.shp") %>%
  filter(code_insee %in% 1:95)

# Les données ne sont pas dans le bon référentiel (WGS 84).
# La projection Lambert 93 du référentiel RGF93 a pour référence EPSG:2154.
# regions <- st_transform(regions, 2154)

data_rnn <- st_transform(data_rnn, 4326)

# Ajout des coordonnées dans le tableau pour faciliter la création des labels
# Vu que ce sont des polygones, on calcule leur centre pour avoir un point.
data_rnn <- cbind(data_rnn, st_coordinates(st_point_on_surface(data_rnn)))

# Création de cartes avec ggplot2.

# Localisation des réserves en France métropolitaine
rnn_france <- ggplot(regions) +
  annotation_map_tile(zoom = 5, zoomin = 0, type = "stamenwatercolor") +
  geom_sf(
    aes(fill = nom),
    colour = "black",
    alpha = 0.6,
    show.legend = FALSE
  ) +
  # Lien entre cartes non-zoomée et zoomée
  geom_diagonal(
    aes(x = 14, xend = 12.5, y = 46, yend = 47.2, strength = 50)
  ) +
  geom_label_repel(
    seed = 42,
    data = filter(data_rnn, ID_LOCAL == "RNN112"),
    aes(x = X, y = Y, label = "Haute Chaîne\ndu Jura"),
    size = 4,
    nudge_x = 6,
    nudge_y = 1.2,
    segment.curvature = 0.5,
    segment.ncp = 1,
    segment.angle = 10,
  ) +
  stat_sf_coordinates(data = data_rnn, colour = "darkred", size = 2) +
  annotation_north_arrow(
    location = "bl",
    which_north = "true",
    style = north_arrow_nautical()
  ) +
  coord_sf(datum = st_crs(4326)) +
  theme_linedraw() +
  theme(
    panel.ontop = TRUE,
    panel.background = element_blank(),
    axis.title = element_blank()
  )

# On récupère les limites inférieures et supérieures de la RNN de la haute
# chaîne du Jura.
crop_limits <- st_bbox(filter(data_rnn, ID_LOCAL == "RNN112"))

# On zoome sur la carte des régions en augmentant les limites précédentes
# par 10 km.
crop_regions <- st_crop(regions, crop_limits + c(-0.1, -0.1, 0.15, 0.1))

rnn_jura <- ggplot(crop_regions) +
  annotation_map_tile(zoomin = -1, type = "stamenwatercolor") +
  geom_sf(data = crop_regions, colour = "black", fill = NA, size = 1.05) +
  geom_sf(data = filter(data_rnn, ID_LOCAL == "RNN112"), fill = "darkred") +
  coord_sf(expand = FALSE, datum = st_crs(4326)) +
  theme_map() +
  theme(
    panel.border = element_rect(colour = "black", fill = NA, size = 2),
    panel.ontop = TRUE
  )

layout_design <- c(
  area(t = 1, l = 1, b = 8, r = 7),
  area(t = 5, l = 6, b = 8, r = 8)
)

rnn_france + rnn_jura + 
  plot_layout(design = layout_design) +
  plot_annotation(caption = "\u00a9 OpenStreetMap contributors")
```


[^OGC]: L'OGC est un consortium international qui développe des standards ouverts
(OpenGIS) dans les domaines de la géomatique et de l'information géographique.

[^sf-vignette]: Cf. la [vignette](https://r-spatial.github.io/sf/articles/sf1.html)
du package `sf` parlant de ce sujet.

### Les rasters {#rasters}

Un raster représente une image constituée de pixels (cellules) organisé(e)s sous
la forme d'une grille. C'est la représentation que l'on a l'habitude de voir
lorsque l'on parle d'une image numérique. Chaque pixel est unique et possède
certaines valeurs le caractérisant (comme sa couleur, ses coordonnées, son
altitude...). Les données sont ainsi organisées en **matrice**, où chaque
**cellule** correspond à un pixel. Pour bien superposer le raster à la carte,
les matrices possèdent une en-tête incluant le **Système de Coordonnées de
Référence**, **l'origine** (généralement les coordonnées du coin inférieur droit
de la matrice), ainsi que l'**étendue de la matrice** (le nombre de colonnes, de
lignes et la résolution spatiale [^resolution]).  
De par leurs caractéristiques, les rasters permettent de définir des **données
discrètes** ainsi que des **données continues**.

[^resolution]: Globalement, la résolution spatiale est la **taille réelle du
plus petit élément** représenté dans un jeu de données. Pour le *mode
matriciel*, cela **correspond à la taille de la cellule de la grille**. Par
exemple, si une cellule représente une surface réelle de 10 x 10 m, alors la
résolution est de 10 m. La résolution spatiale permet donc de **définir le
niveau de détail** du jeu de données. La netteté de l'image est ainsi dépendante
de la résolution spatiale puisqu'il y aura plus de détails capturés avec des
cellules de petite taille (résolution élevée ou fine) qu'avec des cellules de
grande taille (résolution basse ou grossière).


## Les Systèmes de Coordonnées de Référence Géographiques et Projetées {#CRS}


***

## Liste de ressources Internet utiles {.unnumbered #ref-sig}

<!-- TODO : Séparer les ressources de packages R pour plus de lisibilité -->

* [Guide](https://geocompr.robinlovelace.net/) sur les analyses de données
géographiques, leur visualisation et leur modélisation sur R
* [Introduction](https://statnmap.com/2018-07-14-introduction-to-mapping-with-sf-and-co/)
à l'utilisation des packages de cartographie sur R
* [Introduction](https://www.infoworld.com/article/3505897/how-to-do-spatial-analysis-in-r-with-sf.amp.html)
au package `sf`
* [Édition](https://github.com/r-spatial/mapedit) interactive de cartes avec
`mapedit`
* [introduction](https://mhallwor.github.io/_pages/welcome) à l'utilisation de R
comme un SIG
* [Introduction](http://eriqande.github.io/rep-res-web/lectures/making-maps-with-R.html)
pour créer des cartes avec R
* [Introduction](https://thinkr.fr/sil-te-plait-dessine-moi-carte-r/)
en français pour créer des cartes avec R
* Introduction en français sur le package 
[`rgeoapi`](https://colinfay.me/carte-r-rgeoapi-ggplot2/)
* [Zoomer](https://rgeomatic.hypotheses.org/tag/sf) sur une carte avec R
* [Tracer des cartes avec `ggplot2`](https://rpubs.com/huanfaChen/ggplotShapefile)
via des fichiers *shapefiles*
* [Tutoriel](https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html)
pour dessiner des cartes avec R, `sf` et `ggplot2`
* [Cartes interactives](https://r-spatial.github.io/mapview/) avec `mapview`
* [Cartes interactives](https://rstudio.github.io/leaflet/) avec `leaflet`
* Guide pour faire des
[cartes en 3D](https://www.tylermw.com/a-step-by-step-guide-to-making-3d-maps-with-satellite-imagery-in-r/)
à partir d'une imagerie satellite
* Utilisation du package [`rayshader`](https://www.rayshader.com/) pour la
création de cartes en 2D et 3D
* Manipulation et visualisation de données
[LiDAR](https://github.com/Jean-Romain/lidR) pour la foresterie avec `lidr`
* [Blog français](https://www.sigterritoires.fr/index.php/concepts/) contenant
divers tutoriels sur la SIG et QGis
* [NaturaGIS](https://naturagis.fr/) : tutoriels et ressources sur la géomatique, les SIG et leurs usages pour l'environnement
* [Documentation officielle](https://docs.qgis.org/3.10/fr/docs/) de QGIS
